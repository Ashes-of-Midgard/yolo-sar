请你为我实现一个对图像中目标检测结果的后处理脚本：

给定两个目录：images_root, labels_root

images_root中包含若干图像，图像格式为常见的图像格式；labels_root包含若干.txt格式的检测结果文件。检测结果文件与图像一一对应，名称仅在后缀名上不同。

每一个txt结果文件当中，格式如下：
```
4 0.6145519614219666 0.263671875 0.625983715057373 0.28358525037765503 0.5885801911354065 0.3694746494293213 0.5771484375 0.34956127405166626
4 0.3218342661857605 0.5272374749183655 0.34222498536109924 0.5627756118774414 0.2937750816345215 0.6739720702171326 0.27338436245918274 0.6384339332580566
4 0.5687585473060608 0.05067303031682968 0.5857345461845398 0.08038102835416794 0.5471952557563782 0.1684708297252655 0.5302192568778992 0.13876283168792725
```
有9列数字，中间由空格进行分隔。第一列数字是一个整数，代表了目标的类别。从第2列到第9列是目标检测框的四个点归一化的坐标。按照x1,y1,x2,y2,x3,y3,x4,y4的格式排列，四个点按照顺时针进行编号。

现在假设整个图像集合按照场景分为若干组图像，每一个场景下的图像当中，目标之间的相对位置、目标的检测框方向不会有较大的偏差。

该后处理脚本会对所有图像检测结果进行聚类，对于包含结果较多的聚类，视为某一场景下的正常检测结果；而对于包含结果较为稀少的聚类，视为是因为漏检或者虚假而造成的异常检测结果。

脚本的大致流程如下：
1. 读取所有标签文件，提取检测框，计算中心点。
2. 进行聚类，找出异常样本和正常样本。
3. 对于每个正常聚类，找到它的代表样本。
4. 对于每个异常样本，找到它匹配程度最高的正常聚类代表。
5. 根据匹配结果，在异常样本中补全漏检的框。
6. 根据匹配结果，在异常样本中抑制虚警的框。（可选）
7. 保存处理后的标签文件。


接下来，我将具体阐述每一个环节的实现方式：

# 1. 读取所有标签文件，提取检测框，计算中心点：

遍历读取所有的图像检测结果，对于每一个检测结果
1. 计算所有目标检测框的中心点，以四个角点的平均坐标作为中心点
2. 将所有目标按照中心点从上到下、从左到右的顺序排序，即如果一个目标的中心点在另一个目标中心点上方，则它的编号在前，如果中心点坐标在y方向上相同，则以左边的目标在前
3. 按照2中排序的结果，将中心点坐标首尾相连，组成一个向量，即(x1,y1,x2,y2,...,xn,yn)，其中n是目标的总数量；同时也将对应目标的检测框坐标首尾相连，组成另一个向量
4. 将3中中心点首尾相连得到的向量存储为矩阵$V\in\R^{m\times 2n}$，其中$n$是所有图像当中检出目标的最大数量，$m$是图像总数，对于检出目标少于最大值的图像，在它的向量后面补0.
5. 将3中检测框坐标首尾相连得到的向量存储为矩阵$U\in\R^{m\times 8n}$

# 2. 进行聚类，找出异常样本和正常样本：
以矩阵$V$的行向量之间的欧式距离为度量指标，对检测结果进行聚类。聚类算法使用DBSCAN，其中的参数eps以及最小的聚类样本数$t_n$都是可以指定的量。

正常结果所构成的聚类，视为相同场景下图像的正确检测结果。未能归类到某一聚类的离群点，视为异常结果，异常结果是由于漏检或虚假所得到的错误检测结果。

将所有异常结果对应的$V, U$矩阵行向量合并为集合$V^a=\{v^a_1,v^a_2,\dots,v^a_k\}$和$U^a=\{u^a_1,u^a_2,\dots,u^a_k\}$，其中$V^a$是由矩阵$V$中的行向量组成，而$U^a$是由矩阵$U$当中的行向量构成，$a$表示anormal. 也就是异常结果的中心点列表和检测框列表构成的集合。

# 3. 对于每个正常聚类，找到它的代表样本
对于正常结果构成的聚类，将其中距离聚类中心最近的检测结果，作为它的代表。将非异常结果聚类的代表所对应的$V, U$矩阵行向量组成集合$V^n=\{v^n_1,v^n_2,\dots,v^n_l\}$和$U^n=\{u^n_1,u^n_2,\dots,u^n_l\}$，其中$V^n$是由矩阵$V$中的行向量组成，而$U^n$是由矩阵$U$当中的行向量构成，$n$表示normal. 也就是正常结果的中心点列表和检测框列表构成的集合。

# 4. 对于每个异常样本，找到它匹配程度最高的正常聚类代表
对于每一个$V^a$中的向量，根据它与$V^n$中向量之间的匹配程度，将其归类到某一个场景下。给定任意两个$v^a_i\in V^a$和$v^n_j\in V^n$，匹配程度计算方式如下：

1. 对于每一个$v^a_i$当中的中心点$(x^{ai}_p,y^{ai}_p)$，即$v^a_i[2p,2p+1]$，遍历$v^{n}_j$当中的中心点
    1. 对于每一个$v^{n}_j$当中的中心点$(x^{nj}_q,y^{nj}_q)$，即$v^n_j[2q,2q+1]$，计算$(x^{ai}_p,y^{ai}_p)$与$(x^{nj}_q,y^{nj}_q)$之间的欧式距离$d^{i,j}_{p,q}$

2. 将中心点两两之间的欧式距离作为路径权重，构建二分图。按照一个可调整的距离阈值$t_d$，将超过阈值的两点视为不相连。随后对该二分图进行贪心算法匹配，即对于每一个$v^a_i$的中心点，将它和与之最接近的，存在相连关系的，且未被匹配的$v^n_j$中心点进行匹配。

3. 以2当中匹配的数量作为$v^a_i\in V^a$和$v^n_j\in V^n$的匹配程度。

将每个$v^a_i$以及其对应的$u^a_i$归类到具有最大匹配程度的场景当中。

# 5. 根据匹配结果，在异常样本中补全漏检的框
归类完成后，利用匹配的场景中其他检测结果的信息弥补异常结果当中的漏检现象，具体逻辑如下：
1. 假设与$v^a_i$匹配程度最大的正常结果是$v^n_j$. 根据$v^a_i$与$v^n_j$之间中心点的匹配关系，找到$v^n_j$当中未能与$v^a_i$匹配的中心点，记为$v^n_j[2q,2q+1]$.

2. 重新打开images_root目录下，对应于$v^a_i$的图像，以$v^n_j[2q,2q+1]$为中心点，裁剪出宽度和高度为图像宽高八分之一的区域，记为X。另一方面，打开对应于$v^n_j$的图像，找到检测框$u^n_j[8q:8(q+1)]$的水平包络框，将其裁剪下来，记为K。

3. 以K作为卷积核，对X进行卷积匹配，输出K与X局部的匹配程度特征图。卷积的stride=1，padding根据K的实际尺寸设置，使得卷积后的特征图尺寸与卷积前一致。卷积操作通过pytorch库实现。

4. 以特征图当中激活值最大的像素点，作为中心点，生成一个尺寸、方向和$u^n_j[8q:8(q+1)]$相同的检测框，并补充到$v^a_i$的检测结果当中。

# 6. 根据匹配结果，在异常样本中抑制虚警的框（可选）
该环节以一个命令行参数决定是否执行。具体逻辑如下：
假设与$v^a_i$匹配程度最大的正常结果是$v^n_j$. 根据$v^a_i$与$v^n_j$之间中心点的匹配关系，找到$v^a_i$当中未能与$v^n_j$匹配的中心点，删除该中心点对应的检测结果。

# 7. 保存处理后的标签文件
将处理完成以后的异常检测结果，连同正常检测结果，以相同的.txt格式输出到指定目录processed_labels_root下。

综上所述，需要在执行时指明的参数包括：1. 聚类算法的参数eps和$t_n$ 2. 中心点欧氏距离的阈值$t_d$ 3. 相关的文件路径：images_root, labels_root, processed_labels_root

这三个参数均通过代码当中的常量指明

而是否消除疑似虚警的框，则通过命令行参数决定